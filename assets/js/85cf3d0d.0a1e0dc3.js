"use strict";(self.webpackChunkdocusaurus_docs=self.webpackChunkdocusaurus_docs||[]).push([[4966],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var u=r.createContext({}),l=function(e){var t=r.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=l(e.components);return r.createElement(u.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,u=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=l(n),h=a,m=p["".concat(u,".").concat(h)]||p[h]||d[h]||o;return n?r.createElement(m,i(i({ref:t},c),{},{components:n})):r.createElement(m,i({ref:t},c))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=h;var s={};for(var u in t)hasOwnProperty.call(t,u)&&(s[u]=t[u]);s.originalType=e,s[p]="string"==typeof e?e:a,i[1]=s;for(var l=2;l<o;l++)i[l]=n[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},2517:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var r=n(7462),a=(n(7294),n(3905));const o={},i="About Anti Corruption Layer",s={unversionedId:"architecture/angular/explanation/anti-corruption-layer",id:"architecture/angular/explanation/anti-corruption-layer",title:"About Anti Corruption Layer",description:"Background",source:"@site/docs/architecture/angular/explanation/anti-corruption-layer.mdx",sourceDirName:"architecture/angular/explanation",slug:"/architecture/angular/explanation/anti-corruption-layer",permalink:"/software-engineering-toolbox/docs/architecture/angular/explanation/anti-corruption-layer",draft:!1,editUrl:"https://github.com/wasdJens/software-engineering-toolbox/docs/architecture/angular/explanation/anti-corruption-layer.mdx",tags:[],version:"current",frontMatter:{},sidebar:"architectureSidebar",previous:{title:"Angular Architecture",permalink:"/software-engineering-toolbox/docs/architecture/angular/Intro"},next:{title:"About Building Blocks Concept",permalink:"/software-engineering-toolbox/docs/architecture/angular/explanation/building-blocks"}},u={},l=[{value:"Background",id:"background",level:2},{value:"Transformation Service",id:"transformation-service",level:2},{value:"Illustrations",id:"illustrations",level:2}],c={toc:l},p="wrapper";function d(e){let{components:t,...o}=e;return(0,a.kt)(p,(0,r.Z)({},c,o,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"about-anti-corruption-layer"},"About Anti Corruption Layer"),(0,a.kt)("h2",{id:"background"},"Background"),(0,a.kt)("p",null,"The reason for the anti corruption layer approach in frontend development is to create an abstraction between API requests and the internal data model that can be used.\nFor example you have no design choice about the API requests and depend on another team to provide you with the data you need.\nThis can lead to a situation where you have to change your internal data model because the API changed.\nDepending on how often the API makes changes it can also happen that you need to update multiple components.\nThis can be avoided by creating an anti corruption layer that transforms the data from the API to your internal data model.\nIt provides you with the option to have your own data model which you can use in your frontend application.\nIt also makes it easier to combine two or more API requests into one data model.\nWhen it comes to API data model changes you simply need to update a single file where you map the API to your own data model instead of updating each component on its own."),(0,a.kt)("h2",{id:"transformation-service"},"Transformation Service"),(0,a.kt)("p",null,"The integration of an anti corruption layer for an angular application is done by creating a new service that lives between your API requests and transforming the data to your own data model.\nWhen using the angular http client you can pipe the http response and pass it to the transformation service.\nIn the beginning you can use a single service for all transformations.\nIf you notice that you have a lot of different APIs you consume it makes sense to split into multiple services."),(0,a.kt)("p",null,"Many teams often prefer to use the same data model on API and Client side.\nWhile this makes working with the data easier it often leads to a lot of maintenance work once the API changes a single field name.\nAlso when you are using different programming languages between API and Client side it can be hard to keep the data models in sync.\nIt is also often hard to map raw data models to frontend components the user sees.\nBecause the user often gets an aggregation of multiple API requests it makes sense to have a data model that is optimized for the frontend.\nThe anti corruption layer approach also makes it easier to write integration tests to verify what your API sends is what you expect and you can fully unit test this implementation. "),(0,a.kt)("h2",{id:"illustrations"},"Illustrations"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Service structure")),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Anti Corruption Layer Service Structure",src:n(2265).Z,width:"651",height:"214"})),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Changes made to the API")),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Anti Corruption Layer API Changes",src:n(675).Z,width:"695",height:"362"})))}d.isMDXComponent=!0},2265:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/images/Anti_Corruption1-5738516bb5a15b33a7e0abc54f099985.svg"},675:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/images/Anti_Corruption2-ba09b8247ebee01866777cb570e05432.svg"}}]);